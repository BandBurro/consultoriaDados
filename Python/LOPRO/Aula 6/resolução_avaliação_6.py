# -*- coding: utf-8 -*-
"""Resolução Avaliação 6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MMBAV8u2izcVpJiHt9Xq7S6CvMjOkd6I

# Exercicio 1

Desenvolva o programa que leia vários valores reais e no final mostre as seguintes informações:

- A quantidade de valores digitados;
- A soma dos valores digitados;
- A média aritmética dos valores digitados;
- E a quantidade de valores digitados maior que 20.

Findings:

- A ordem dos ifs importou bastante, quando o segundo elif estava antes como primeira condicional, o codigo nao compilava os valores maiores que 20 ja que todo valor maior que 20 tambem é maior que 0, portanto, o codigo parava na primeira condicional
- Foi necessario um contador especifico para os numeros maiores que 20
- A condição do while me deu trabalho, pois tentei usar continue, mas parece ser necessario um break em algum momento
- Apesar de "matematicamente impreciso", ja que o 0 é um numero natural, que faz parte dos reais, usei ele como parametro de break--caso contrario, seria adicionado apenas 1 a mais para a variavel do "ct" para cada 0 digitado na variavel "valor"
"""

somador = 0
ct = 0
v20 = 0
while True:
  valor = int(input('digite um valor real: '))
  if valor > 20: # somador de numeros maiores que 20
    v20 = v20 + 1
    somador = somador + valor # somador geral
  elif valor > 0:
    somador = somador + valor # somador geral
  elif valor < 0: # verifica se o input é um valor real
    print('este não é um numero real: ')
    valor = int(input('digite um valor real: ')) # captura um novo numero para 'valor'
    continue # joga o leitor de volta ao loop inicial caso o input não cumpra o primeiro if statement
  elif valor == 0:
    break
  ct = ct + 1 # contador geral
print(f'a quantidade de valores digitados foi {ct}')
print(f'a soma dos valores digitados foi {somador}')
print(f'a media dos valores digitados foi {somador/ct}')
print(f'o numero de valores maiores que 20 digitados foi {v20}')

"""A sugestão de melhoria do Gemini em performance foi

1) no sentido de compilar codigos "somador = somador + ct" em um unico "Augmented Assignment Operators".

'' Other Augmented Assignment Operators:

There are operators for other common operations too:

- -=: Subtraction (e.g., x -= 5 means x = x - 5)

- *=: Multiplication (e.g., y *= 2 means y = y * 2)

- /=: Division (e.g., z /= 3 means z = z / 3)

- %=: Modulus (remainder) (e.g., a %= 4 means a = a % 4)''

e

2) sumarizar o meu segundo elif statement em um unico bloco de codigo de if dentro de if, de forma que a primeira condicional if é checada, e adiciona o valor digitado ao somador, em sequencia, checa a validez do input > 20, onde, caso cumprida a condição, adiciona um ao contador do v20.

"""

somador = 0
ct = 0
v20 = 0
while True:
    valor = int(input('digite um valor real: '))

    # Combined conditional logic for efficiency
    if valor > 0:
        somador += valor  # Using augmented assignment for conciseness
        if valor > 20:
            v20 += 1      # Using augmented assignment for conciseness

    elif valor < 0:
        print('este não é um numero real: ')
        continue
    elif valor == 0:
        break

    ct += 1  # Using augmented assignment and placed outside conditionals for correct counting

print(f'a quantidade de valores digitados foi {ct}')
print(f'a soma dos valores digitados foi {somador}')
print(f'a media dos valores digitados foi {somador/ct}')
print(f'o numero de valores maiores que 20 digitados foi {v20}')

"""# Exercicio 2

Implemente o programa que leia a nota de vários alunos de uma turma e gere uma tela de saída com as seguintes informações:

- a quantidade de alunos aprovados,
- a quantidade de alunos reprovados e
- a quantidade de alunos que fizeram a prova.

Considere que o aluno será aprovado com nota for maior ou igual a cinco.

Findings:

- ao colocar o compilador do ct logo abaixo do while statement, o codigo acaba pegando o -1 para dar o break no loop como "nota" e adiciona um a mais na contagem.
- idealmente, o contadores devem ficar no final do codigo, fora de blocos condicionais, mas dentro do loop do while.
"""

print('digite sua nota ou -1 para sair do programa')
ct = 0
ct_Aprovado = 0
ct_Reprovado = 0
while True:
  nota = float(input('digite sua nota: ')) # input de notas do usuario
  if nota >= 5 and nota <= 10:
    print('Aprovado!')
    ct_Aprovado += 1 # contador de aprovados
  elif nota == -1: # break do loop
    break
  elif nota < 0 and nota != -1: # computador é burro e nao entende logica aristotelica crua, tem q detalhar
    print('Nota invalida, não tem como tirar e.g -2 em uma prova')
    continue # joga o usuario de volta ao inicio do loop caso digite uma nota inválida
  else:
    print('Reprovado!')
    ct_Reprovado += 1 # contador de reprovados
  ct += 1 # contador geral, fora dos blocos condicionais e sempre contará +1
print(f'A quantidade de alunos aprovados foi {ct_Aprovado}')
print(f'A quantidade de alunos reprovados foi {ct_Reprovado}')
print(f'A quantidade de alunos que fizeram a prova foi {ct}')

"""Sugestoes de melhoria do Gemini foi no sentido de

1) melhorar nomeclatura das variaveis, para algo mais glanceable,

2) remanejamento dos blocos condicionais para melhor readability, botando o resto dos parametros de condição dentro de um else que engloba tudo que não passa por >= 5 AND <= 10 e o -1 de break,

3) contador de numero total de estudantes depois do break, mas ainda dentro do loop para evitar que calcule-se notas invalidas (serão capturadas pelas condicionais previas) ou o -1 do break como numero total de alunos
"""

print('digite sua nota ou -1 para sair do programa')
total_students = 0
passed_students = 0
failed_students = 0

while True:
    grade = float(input('digite sua nota: '))

    if grade >= 5:
        print('Aprovado!')
        passed_students += 1
    elif grade == -1:
        break
    else:  # Combine invalid and failing grades
        if grade <= 0 and grade != -1:
            print('Nota invalida, não tem como tirar e.g -2 em uma prova')
        else:
            print('Reprovado!')
            failed_students += 1
    # Counts only valid grades
    total_students += 1
    continue

print(f'A quantidade de alunos aprovados foi {passed_students}')
print(f'A quantidade de alunos reprovados foi {failed_students}')
print(f'A quantidade de alunos que fizeram a prova foi {total_students}')

"""# Exercicio 3

Construa o programa que calcule a média aritmética dos números pares e a média aritmética dos números ímpares.

O usuário fornecerá os valores de entrada que pode ser um número qualquer par ou ímpar.

A condição de saída será o número 0 (zero).
"""

print('Digite um número natural ou 0 para sair')
ct = 0
somador_Par = 0
somador_Impar = 0
while True:
  valor = int(input('Providencie seu numero natural: '))
  if valor == 0:
    break
  elif valor % 2 == 0 and valor > 0:
    somador_Par += valor
  else:
    if valor < 0:
      print('Este valor não é natural')
      continue
    elif valor % 2 != 0:
      somador_Impar += valor
  ct += 1
print(f'a média dos valores pares é {somador_Par/ct}')
print(f'a média dos valores impares é {somador_Impar/ct}')

"""Sugestoes de melhoria do Gemini

1) remover o "continue" do codigo original, ja que é implicito a quebra do loop e volta do leitor ao inicio do codigo,

2) remusir a quantidade de condicionais, deixando o else compilar todos os resultados restantes (positivos e impares) depois de passado pelo filtro do if e dois elifs.
"""

print('Digite um número natural ou 0 para sair')
ct = 0
somador_Par = 0
somador_Impar = 0
while True:
  valor = int(input('Providencie seu numero natural: '))
  if valor == 0:
    break
  elif valor % 2 == 0 and valor > 0:
    somador_Par += valor
  elif valor < 0:
    print('Este valor não é natural')
  else:  # valor is odd and positive
    somador_Impar += valor
  ct += 1
print(f'a média dos valores pares é {somador_Par/ct}')
print(f'a média dos valores impares é {somador_Impar/ct}')